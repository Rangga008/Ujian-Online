import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import Head from "next/head";
import Layout from "@/components/Layout";
import { api } from "@/lib/api";
import Link from "next/link";
import toast from "react-hot-toast";
import { classesApi } from "@/lib/classesApi";
import { subjectsApi } from "@/lib/subjectsApi";
import { semestersApi } from "@/lib/semestersApi";
import { gradesApi } from "@/lib/gradesApi";
import { useAuthStore } from "@/store/authStore";
import {
	compressImageBrowser,
	estimateCompressionRatio,
	formatFileSize,
} from "@/lib/imageCompression";
import { getImageUrl } from "@/lib/imageUrl";
import QuestionModal from "@/components/QuestionModal";

interface Question {
	id: number;
	questionText: string;
	type: string;
	points: number;
	options?: string[];
	correctAnswer?: string;
	imageUrl?: string;
	orderIndex: number;
}

interface Exam {
	id: number;
	title: string;
	description: string;
	status: string;
	duration: number;
	startTime: string;
	endTime: string;
	totalQuestions: number;
	totalScore: number;
	randomizeQuestions: boolean;
	showResultImmediately: boolean;
	classId: number;
	subjectId: number;
	semesterId: number;
	questions: Question[];
	targetType?: string;
	grade?: string;
}

interface Class {
	id: number;
	name: string;
}

interface Semester {
	id: number;
	name: string;
	year: string;
	isActive: boolean;
}

const QuestionTypes = [
	{ value: "multiple_choice", label: "Pilihan Ganda" },
	{ value: "mixed_multiple_choice", label: "Pilihan Ganda Majemuk" },
	{ value: "true_false", label: "Benar/Salah" },
	{ value: "essay", label: "Essay" },
];

export default function ExamEditPage() {
	const router = useRouter();
	const { id } = router.query;
	const { user } = useAuthStore();
	const [exam, setExam] = useState<Exam | null>(null);
	const [loading, setLoading] = useState(true);
	const [saving, setSaving] = useState(false);
	const [classes, setClasses] = useState<Class[]>([]);
	const [subjects, setSubjects] = useState<any[]>([]);
	const [semesters, setSemesters] = useState<Semester[]>([]);
	const [grades, setGrades] = useState<any[]>([]);

	const [formData, setFormData] = useState({
		title: "",
		description: "",
		duration: 60,
		startTime: "",
		endTime: "",
		classId: 0,
		subjectId: 0,
		semesterId: 0,
		totalScore: 100,
		randomizeQuestions: false,
		showResultImmediately: false,
		targetType: "class" as "class" | "grade",
		gradeId: "",
	});

	// Question form state
	const [showQuestionModal, setShowQuestionModal] = useState(false);
	const [editingQuestionIndex, setEditingQuestionIndex] = useState<
		number | null
	>(null);
	const [questionForm, setQuestionForm] = useState({
		questionText: "",
		type: "multiple_choice",
		points: 1,
		options: ["", "", "", ""],
		correctAnswer: "",
		imageUrl: "",
		imageFile: null as File | null,
	});

	useEffect(() => {
		if (id) {
			fetchExam();
			fetchClasses();
			fetchSemesters();
			fetchGrades();
		}
	}, [id]);

	const fetchExam = async () => {
		try {
			setLoading(true);
			const response = await api.get(`/exams/${id}`);
			const examData = response.data;
			setExam(examData);

			// Parse grade from examData if targetType is 'grade'
			let matchedGradeId = "";
			if (examData.targetType === "grade" && examData.grade) {
				try {
					const gradesData = await gradesApi.getAll();
					const matchedGrade = gradesData.find((g: any) => {
						const gradeStr = `${g.name} (${g.section})`;
						return gradeStr === examData.grade;
					});
					if (matchedGrade) {
						matchedGradeId = matchedGrade.id.toString();
					}
				} catch (error) {
					console.error("Error matching grade:", error);
				}
			}

			setFormData({
				title: examData.title,
				description: examData.description,
				duration: examData.duration,
				startTime: examData.startTime?.slice(0, 16).replace(" ", "T"),
				endTime: examData.endTime?.slice(0, 16).replace(" ", "T"),
				classId: examData.classId || 0,
				subjectId: examData.subjectId || 0,
				semesterId: examData.semesterId || 0,
				totalScore: examData.totalScore || 100,
				randomizeQuestions: examData.randomizeQuestions || false,
				showResultImmediately: examData.showResultImmediately || false,
				targetType: (examData.targetType as "class" | "grade") || "class",
				gradeId: matchedGradeId,
			});

			// Fetch subjects for the selected semester
			if (examData.semesterId) {
				const subjectsData = await subjectsApi.getAll();
				setSubjects(subjectsData);
			}
		} catch (error) {
			toast.error("Gagal memuat detail ujian");
			router.push("/exams");
		} finally {
			setLoading(false);
		}
	};

	const fetchClasses = async () => {
		try {
			const data = await classesApi.getAll();
			// Filter for teachers - only show their assigned class
			const filtered =
				user?.role === "teacher" &&
				user?.teachingClasses &&
				user.teachingClasses.length > 0
					? data.filter((c) =>
							user.teachingClasses!.some((tc: any) => tc.id === c.id)
					  )
					: data;
			setClasses(filtered);
		} catch (error) {
			console.error("Failed to fetch classes:", error);
		}
	};

	const fetchSemesters = async () => {
		try {
			const data = await semestersApi.getAll();
			setSemesters(data);
		} catch (error) {
			console.error("Failed to fetch semesters:", error);
		}
	};

	const fetchGrades = async () => {
		try {
			const data = await gradesApi.getAll();
			setGrades(data);
		} catch (error) {
			console.error("Failed to fetch grades:", error);
		}
	};

	const handleSaveExam = async (e: React.FormEvent) => {
		e.preventDefault();

		// Validate datetime fields
		if (!formData.startTime) {
			toast.error("Masukkan waktu mulai");
			return;
		}

		if (!formData.endTime) {
			toast.error("Masukkan waktu selesai");
			return;
		}

		const startDate = new Date(formData.startTime);
		const endDate = new Date(formData.endTime);

		if (isNaN(startDate.getTime())) {
			toast.error("Format waktu mulai tidak valid");
			return;
		}

		if (isNaN(endDate.getTime())) {
			toast.error("Format waktu selesai tidak valid");
			return;
		}

		if (startDate >= endDate) {
			toast.error("Waktu selesai harus lebih besar dari waktu mulai");
			return;
		}

		if (formData.targetType === "class" && !formData.classId) {
			toast.error("Pilih kelas terlebih dahulu");
			return;
		}

		if (formData.targetType === "grade" && !formData.gradeId) {
			toast.error("Pilih angkatan terlebih dahulu");
			return;
		}

		if (!exam || exam.questions.length === 0) {
			toast.error("Tambahkan minimal 1 soal");
			return;
		}

		try {
			setSaving(true);

			// Prepare questions data from current exam state
			const processedQuestions = exam.questions.map((q, idx) => ({
				questionText: q.questionText,
				type: q.type,
				points: q.points,
				orderIndex: idx,
				imageUrl: q.imageUrl || "",
				options: q.type === "essay" ? [] : q.options || [],
				correctAnswer: q.correctAnswer || "",
			}));

			const payload: any = {
				title: formData.title,
				description: formData.description,
				duration: formData.duration,
				startTime: new Date(formData.startTime).toISOString(),
				endTime: new Date(formData.endTime).toISOString(),
				subjectId: formData.subjectId || undefined,
				semesterId: formData.semesterId || undefined,
				totalScore: 100,
				totalQuestions: processedQuestions.length,
				randomizeQuestions: formData.randomizeQuestions,
				showResultImmediately: formData.showResultImmediately,
				targetType: formData.targetType,
				questions: processedQuestions, // Include questions in update
			};

			if (formData.targetType === "class") {
				payload.classId = formData.classId || undefined;
				payload.grade = undefined;
			} else {
				const selectedGrade = grades.find(
					(g) => g.id === Number(formData.gradeId)
				);
				if (selectedGrade) {
					payload.grade = selectedGrade.name;
					payload.classId = undefined;
				}
			}

			await api.put(`/exams/${id}`, payload);
			toast.success("Ujian berhasil diperbarui");
			router.push(`/exams/${id}`);
		} catch (error: any) {
			toast.error(error.response?.data?.message || "Gagal memperbarui ujian");
		} finally {
			setSaving(false);
		}
	};

	const handleAddQuestion = async (questionData: any) => {
		if (!questionData.questionText) {
			toast.error("Pertanyaan tidak boleh kosong");
			return;
		}

		// Validasi berdasarkan tipe soal
		if (questionData.type === "essay") {
			// Essay hanya memerlukan pertanyaan
		} else if (questionData.type === "true_false") {
			if (!questionData.correctAnswer) {
				toast.error("Pilih jawaban Benar atau Salah");
				return;
			}
		} else {
			// Multiple choice dan mixed multiple choice butuh pilihan
			if (!questionData.options.some((o: string) => o.trim())) {
				toast.error("Minimal ada satu pilihan jawaban");
				return;
			}
			if (!questionData.correctAnswer) {
				toast.error("Pilih jawaban yang benar");
				return;
			}
		}

		try {
			const formDataToSend = new FormData();
			formDataToSend.append("questionText", questionData.questionText);
			formDataToSend.append("type", questionData.type);
			formDataToSend.append("points", questionData.points.toString());

			if (questionData.type !== "essay") {
				if (questionData.type === "true_false") {
					formDataToSend.append("options", JSON.stringify(["Benar", "Salah"]));
					formDataToSend.append("correctAnswer", questionData.correctAnswer);
				} else if (questionData.type === "mixed_multiple_choice") {
					const options = questionData.options.filter((o: string) => o.trim());
					formDataToSend.append("options", JSON.stringify(options));

					// Convert indices to option text
					const selectedIndexes = (questionData.correctAnswer || "")
						.split(",")
						.map((x: string) => Number(x.trim()))
						.filter((n: number) => !Number.isNaN(n));

					const mappedAnswers = selectedIndexes
						.map((idx: number) => (options[idx] ? options[idx] : ""))
						.filter(Boolean)
						.join(",");

					formDataToSend.append("correctAnswer", mappedAnswers || "");
				} else {
					formDataToSend.append(
						"options",
						JSON.stringify(questionData.options.filter((o: string) => o.trim()))
					);
					formDataToSend.append("correctAnswer", questionData.correctAnswer);
				}
			}

			// Handle image upload dengan kompresi
			if (questionData.imageFile) {
				try {
					const compressed = await compressImageBrowser(questionData.imageFile);
					formDataToSend.append("image", compressed.file);
					console.log(
						`Gambar dikompres: ${formatFileSize(
							questionData.imageFile.size
						)} → ${formatFileSize(compressed.file.size)}`
					);
				} catch (error) {
					console.error("Error compressing image:", error);
					toast.error("Gagal mengompres gambar");
					return;
				}
			} else if (editingQuestionIndex !== null && questionData.imageUrl) {
				formDataToSend.append("imageUrl", questionData.imageUrl);
			}

			if (editingQuestionIndex !== null) {
				await api.put(
					`/exams/${id}/questions/${exam!.questions[editingQuestionIndex].id}`,
					formDataToSend,
					{
						headers: { "Content-Type": "multipart/form-data" },
					}
				);
				toast.success("Soal berhasil diperbarui");
			} else {
				await api.post(`/exams/${id}/questions`, formDataToSend, {
					headers: { "Content-Type": "multipart/form-data" },
				});
				toast.success("Soal berhasil ditambahkan");
			}

			resetQuestionForm();
			setEditingQuestionIndex(null);
			setShowQuestionModal(false);
			fetchExam();
		} catch (error: any) {
			toast.error(error.response?.data?.message || "Gagal menyimpan soal");
		}
	};

	const resetQuestionForm = () => {
		setQuestionForm({
			questionText: "",
			type: "multiple_choice",
			points: 1,
			options: ["", "", "", ""],
			correctAnswer: "",
			imageUrl: "",
			imageFile: null,
		});
	};

	const handleEditQuestion = (index: number) => {
		if (!exam) return;
		const question = exam.questions[index];
		setEditingQuestionIndex(index);

		let correctAnswer = question.correctAnswer || "";

		// For mixed_multiple_choice, convert option text back to indices
		if (question.type === "mixed_multiple_choice" && question.options) {
			const answers = (question.correctAnswer || "")
				.split(",")
				.map((a) => a.trim());
			const indices = answers
				.map((ans) => question.options!.findIndex((opt) => opt === ans))
				.filter((idx) => idx !== -1);
			correctAnswer = indices.join(",");
		}

		setQuestionForm({
			questionText: question.questionText,
			type: question.type,
			points: question.points,
			options:
				question.type === "essay" ? [] : question.options || ["", "", "", ""],
			correctAnswer,
			imageUrl: question.imageUrl || "",
			imageFile: null,
		});
		setShowQuestionModal(true);
	};

	const handleDeleteQuestion = async (questionId: number) => {
		if (!confirm("Yakin ingin menghapus soal ini?")) return;

		try {
			await api.delete(`/exams/${id}/questions/${questionId}`);
			toast.success("Soal berhasil dihapus");
			fetchExam();
		} catch (error) {
			toast.error("Gagal menghapus soal");
		}
	};

	const handleImageChange = async (e: React.ChangeEvent<HTMLInputElement>) => {
		const file = e.target.files?.[0];
		if (!file) return;

		// Validasi ukuran file (max 5MB sebelum kompresi)
		if (file.size > 5 * 1024 * 1024) {
			toast.error("Ukuran file maksimal 5MB");
			return;
		}

		// Validasi tipe file
		if (!file.type.startsWith("image/")) {
			toast.error("File harus berupa gambar");
			return;
		}

		try {
			const ratio = await estimateCompressionRatio(file);
			const estimatedSize = file.size * ratio;

			setQuestionForm({
				...questionForm,
				imageFile: file,
				imageUrl: "", // Clear existing URL when new file selected
			});

			toast.success(
				`File dipilih. Estimasi setelah kompresi: ${formatFileSize(
					estimatedSize
				)}`
			);
		} catch (error) {
			console.error("Error estimating compression:", error);
			setQuestionForm({
				...questionForm,
				imageFile: file,
				imageUrl: "",
			});
		}
	};

	if (loading) {
		return (
			<Layout title="Edit Ujian">
				<div className="card text-center py-12">
					<p className="text-gray-600">Memuat data ujian...</p>
				</div>
			</Layout>
		);
	}

	if (!exam) {
		return (
			<Layout title="Edit Ujian">
				<div className="card text-center py-12">
					<p className="text-gray-600 mb-4">Ujian tidak ditemukan</p>
					<Link href="/exams" className="btn btn-primary">
						Kembali ke Daftar Ujian
					</Link>
				</div>
			</Layout>
		);
	}

	return (
		<Layout title={`Edit Ujian - ${exam.title}`}>
			<Head>
				<title>Edit Ujian - {exam.title} - Admin Panel</title>
			</Head>
			<div className="grid grid-cols-1 lg:grid-cols-3 gap-6 mb-6 px-2 sm:px-0">
				{/* Main Form */}
				<div className="col-span-2">
					<div className="card mb-6">
						<h2 className="text-2xl font-bold mb-6">Informasi Ujian</h2>
						<form onSubmit={handleSaveExam}>
							<div className="space-y-4">
								<div>
									<label className="block text-sm font-medium mb-2">
										Judul Ujian *
									</label>
									<input
										type="text"
										className="input w-full"
										value={formData.title}
										onChange={(e) =>
											setFormData({
												...formData,
												title: e.target.value,
											})
										}
										required
									/>
								</div>

								<div>
									<label className="block text-sm font-medium mb-2">
										Deskripsi
									</label>
									<textarea
										className="input w-full h-24"
										value={formData.description}
										onChange={(e) =>
											setFormData({
												...formData,
												description: e.target.value,
											})
										}
									/>
								</div>

								<div className="grid grid-cols-2 gap-4">
									<div>
										<label className="block text-sm font-medium mb-2">
											Target Ujian *
										</label>
										<select
											className="input w-full"
											value={formData.targetType}
											onChange={(e) =>
												setFormData({
													...formData,
													targetType: e.target.value as "class" | "grade",
													classId: 0,
													gradeId: "",
												})
											}
											required
										>
											<option value="class">Satu Kelas</option>
											<option value="grade">Satu Angkatan</option>
										</select>
									</div>

									{formData.targetType === "class" ? (
										<div>
											<label className="block text-sm font-medium mb-2">
												Kelas *
											</label>
											<select
												className="input w-full"
												value={formData.classId}
												onChange={(e) =>
													setFormData({
														...formData,
														classId: parseInt(e.target.value),
													})
												}
												required
											>
												<option value={0}>Pilih Kelas</option>
												{classes.map((cls) => (
													<option key={cls.id} value={cls.id}>
														{cls.name}
													</option>
												))}
											</select>
										</div>
									) : (
										<div>
											<label className="block text-sm font-medium mb-2">
												Angkatan *
											</label>
											<select
												className="input w-full"
												value={formData.gradeId}
												onChange={(e) =>
													setFormData({
														...formData,
														gradeId: e.target.value,
													})
												}
												required
											>
												<option value="">Pilih Angkatan</option>
												{grades
													.filter((g) => g.isActive)
													.map((grade) => (
														<option key={grade.id} value={grade.id}>
															{grade.name} ({grade.section})
														</option>
													))}
											</select>
											{grades.length === 0 && (
												<p className="text-xs text-orange-600 mt-1">
													⚠️ Belum ada angkatan. Tambahkan di Pengaturan →
													Angkatan
												</p>
											)}
										</div>
									)}

									<div>
										<label className="block text-sm font-medium mb-2">
											Mata Pelajaran
										</label>
										<select
											className="input w-full"
											value={formData.subjectId}
											onChange={(e) =>
												setFormData({
													...formData,
													subjectId: parseInt(e.target.value),
												})
											}
										>
											<option value={0}>Pilih Mata Pelajaran</option>
											{subjects.map((subj) => (
												<option key={subj.id} value={subj.id}>
													{subj.name}
												</option>
											))}
										</select>
									</div>
								</div>

								<div className="grid grid-cols-2 gap-4">
									<div>
										<label className="block text-sm font-medium mb-2">
											Waktu Mulai
										</label>
										<input
											type="datetime-local"
											className="input w-full"
											value={formData.startTime}
											onChange={(e) =>
												setFormData({
													...formData,
													startTime: e.target.value,
												})
											}
										/>
									</div>

									<div>
										<label className="block text-sm font-medium mb-2">
											Waktu Berakhir
										</label>
										<input
											type="datetime-local"
											className="input w-full"
											value={formData.endTime}
											onChange={(e) =>
												setFormData({
													...formData,
													endTime: e.target.value,
												})
											}
										/>
									</div>
								</div>

								<div className="grid grid-cols-2 gap-4">
									<div>
										<label className="block text-sm font-medium mb-2">
											Durasi (menit)
										</label>
										<input
											type="number"
											className="input w-full"
											value={formData.duration}
											onChange={(e) =>
												setFormData({
													...formData,
													duration: parseInt(e.target.value),
												})
											}
											min="1"
										/>
									</div>

									<div>
										<label className="block text-sm font-medium mb-2">
											Total Skor
										</label>
										<input
											type="number"
											className="input w-full"
											value={formData.totalScore}
											onChange={(e) =>
												setFormData({
													...formData,
													totalScore: parseInt(e.target.value),
												})
											}
											min="1"
										/>
									</div>
								</div>

								<div className="space-y-3">
									<label className="flex items-center gap-2 cursor-pointer">
										<input
											type="checkbox"
											checked={formData.randomizeQuestions}
											onChange={(e) =>
												setFormData({
													...formData,
													randomizeQuestions: e.target.checked,
												})
											}
										/>
										<span className="text-sm font-medium">
											Acak urutan soal
										</span>
									</label>

									<label className="flex items-center gap-2 cursor-pointer">
										<input
											type="checkbox"
											checked={formData.showResultImmediately}
											onChange={(e) =>
												setFormData({
													...formData,
													showResultImmediately: e.target.checked,
												})
											}
										/>
										<span className="text-sm font-medium">
											Tampilkan hasil langsung
										</span>
									</label>
								</div>
							</div>

							<div className="mt-6 flex gap-2">
								<button
									type="submit"
									disabled={saving}
									className="btn btn-primary"
								>
									{saving ? "Menyimpan..." : "Simpan Ujian"}
								</button>
								<Link href={`/exams/${exam.id}`} className="btn btn-secondary">
									Batal
								</Link>
							</div>
						</form>
					</div>
				</div>

				{/* Questions Summary */}
				<div>
					<div className="card sticky top-24">
						<h3 className="text-lg font-bold mb-4">Ringkasan Soal</h3>
						<div className="space-y-3 text-sm">
							<div className="flex justify-between items-center py-2 border-b">
								<span className="text-gray-600">Total Soal:</span>
								<span className="font-bold text-lg">
									{exam.questions.length}
								</span>
							</div>
							<div className="space-y-2">
								{QuestionTypes.map((type) => {
									const count = exam.questions.filter(
										(q) => q.type === type.value
									).length;
									return count > 0 ? (
										<div
											key={type.value}
											className="flex justify-between text-gray-600"
										>
											<span>{type.label}:</span>
											<span className="font-medium">{count}</span>
										</div>
									) : null;
								})}
							</div>

							<div className="mt-6 pt-4 border-t">
								<button
									onClick={() => {
										resetQuestionForm();
										setEditingQuestionIndex(null);
										setShowQuestionModal(true);
									}}
									className="btn btn-primary w-full"
								>
									{showQuestionModal ? "Tutup Form" : "+ Tambah Soal"}
								</button>
							</div>
						</div>
					</div>
				</div>
			</div>

			{/* Question Modal */}
			<QuestionModal
				isOpen={showQuestionModal}
				onClose={() => {
					setShowQuestionModal(false);
					setEditingQuestionIndex(null);
					resetQuestionForm();
				}}
				onSave={handleAddQuestion}
				initialData={
					editingQuestionIndex !== null
						? {
								questionText: questionForm.questionText,
								type: questionForm.type,
								points: questionForm.points,
								options: questionForm.options,
								correctAnswer: questionForm.correctAnswer,
								imageUrl: questionForm.imageUrl,
						  }
						: undefined
				}
				isEditing={editingQuestionIndex !== null}
			/>

			{/* Questions List */}
			<div className="card mt-6">
				<h3 className="text-xl font-bold mb-4">Daftar Soal</h3>
				{exam?.questions && exam.questions.length === 0 ? (
					<p className="text-gray-500 text-center py-8">
						Belum ada soal. Klik "Tambah Soal" untuk menambahkan soal pertama.
					</p>
				) : exam?.questions ? (
					<div className="space-y-4">
						{exam.questions.map((question: Question, idx: number) => (
							<div key={question.id} className="border rounded-lg p-4">
								<div className="flex justify-between items-start mb-2">
									<div className="flex-1">
										<p className="font-medium">
											{idx + 1}. {question.questionText}
										</p>
										<div className="flex gap-4 mt-2 text-sm text-gray-600">
											<span>
												Tipe:{" "}
												{
													QuestionTypes.find((t) => t.value === question.type)
														?.label
												}
											</span>
											<span>Poin: {question.points}</span>
										</div>
									</div>
									<div className="flex gap-2">
										<button
											onClick={() => handleEditQuestion(idx)}
											className="text-blue-600 hover:text-blue-800"
										>
											Edit
										</button>
										<button
											onClick={() => handleDeleteQuestion(question.id)}
											className="text-red-600 hover:text-red-800"
										>
											Hapus
										</button>
									</div>
								</div>

								{question.imageUrl && (
									<div className="mt-2">
										<img
											src={getImageUrl(question.imageUrl)}
											alt="Gambar soal"
											className="max-w-xs max-h-48 object-contain rounded border"
										/>
									</div>
								)}

								{question.type !== "essay" && question.options && (
									<div className="mt-3 space-y-1">
										{question.options.map((option: string, optIdx: number) => {
											const isCorrect =
												question.type === "mixed_multiple_choice"
													? (question.correctAnswer || "")
															.split(",")
															.map((a) => a.trim())
															.includes(option)
													: question.correctAnswer === option;

											return (
												<div
													key={optIdx}
													className={`text-sm ${
														isCorrect
															? "text-green-600 font-medium"
															: "text-gray-600"
													}`}
												>
													{String.fromCharCode(65 + optIdx)}. {option}
													{isCorrect && <span className="ml-2">✓</span>}
												</div>
											);
										})}
									</div>
								)}
							</div>
						))}
					</div>
				) : null}
			</div>
		</Layout>
	);
}
